<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Experience - Three.js Demo | Abhinav Chinnusamy</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Interactive 3D experience powered by Three.js. Explore floating 3D text with animations." />
    <meta name="keywords" content="three.js, 3D, webgl, interactive 3D, Abhinav Chinnusamy" />
    <meta name="author" content="Abhinav Chinnusamy" />
    <meta name="robots" content="index, follow" />

    <!-- Open Graph -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content="3D Experience - Three.js Demo | Abhinav Chinnusamy" />
    <meta property="og:url" content="https://cabhinav.com/3d/" />
    <meta property="og:description" content="Interactive 3D experience powered by Three.js." />
    <meta property="og:image" content="https://cabhinav.com/assets/images/profile/my_profile.jpg" />
    <meta property="og:site_name" content="cabhinav.com" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="3D Experience - Three.js Demo" />
    <meta name="twitter:description" content="Interactive 3D experience powered by Three.js." />
    <meta name="twitter:image" content="https://cabhinav.com/assets/images/profile/my_profile.jpg" />
    <meta name="twitter:creator" content="@abhinav_937" />

    <!-- Canonical URL -->
    <link rel="canonical" href="https://cabhinav.com/3d/" />

    <!-- Theme Color -->
    <meta name="theme-color" content="#0a0a0f" />

    <!-- Favicon -->
    <link rel="icon" href="../assets/images/icons/favicon.ico" type="image/x-icon">

    <!-- Styles -->

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            cursor: move;
            user-select: none;
            overflow: hidden;
            background: #0a0a0f;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: white;
        }

        .info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .info-panel h1 {
            font-size: 24px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #ffffff, #a0a0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .info-panel p {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            z-index: 1000;
            font-size: 12px;
            opacity: 0.8;
            max-width: 280px;
        }

        .instructions h3 {
            font-size: 14px;
            margin-bottom: 8px;
            opacity: 1;
        }

        .instructions ul {
            list-style: none;
            padding: 0;
        }

        .instructions li {
            margin-bottom: 4px;
            padding-left: 16px;
            position: relative;
        }

        .instructions li:before {
            content: "â€¢";
            position: absolute;
            left: 0;
            color: #a0a0ff;
        }

        @media (max-width: 768px) {
            .info-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 16px;
            }

            .instructions {
                bottom: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }
        }
    </style>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <!-- 3D Text Canvas Container -->
    <div id="threejs-text-container"></div>

    <div class="info-panel">
        <h1>3D Text Test Page</h1>
        <p>3D text with advanced shader materials. Features TextGeometry with realistic metallic materials.</p>
    </div>

    <!-- Three.js 3D Text with Advanced Shader Materials -->
    <!-- Removed: FloatingText3D import and initialization (file deleted) -->
    <script type="module">
      // import FloatingText3D from '../assets/js/3d-text/floating-text.js'; // File deleted
      // import * as THREE from 'three';
      
      // Script disabled - FloatingText3D class file has been deleted
      /*
      document.addEventListener('DOMContentLoaded', async function() {
        try {
          const floatingText = new FloatingText3D('threejs-text-container');
          await floatingText.init();
          
          // Enhance lighting with multiple directional lights (inspired by progressive lightmap example)
          const THREE = floatingText.THREE;
          const scene = floatingText.scene;
          const renderer = floatingText.renderer;
          
          // Set up tone mapping for better shader material rendering (exact from 3d-material page)
          renderer.toneMapping = THREE.ACESFilmicToneMapping;
          renderer.toneMappingExposure = 1.2;
          renderer.outputEncoding = THREE.sRGBEncoding;
          
          // Enable shadows
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          
          // Create 1 directional light that moves around the text
          const lightCount = 1;
          const dirLights = [];
          const lightOrigin = new THREE.Group();
          lightOrigin.position.set(0, 0, -150); // Center at text position
          scene.add(lightOrigin);
          
          // Create single directional light - much stronger for visible effect
          const dirLight = new THREE.DirectionalLight(0xffffff, 4.0); // Much brighter - increased from 1.5 to 4.0
          dirLight.position.set(200, 300, -50); // Initial position
          dirLight.castShadow = true;
          dirLight.shadow.camera.near = 1;
          dirLight.shadow.camera.far = 1000;
          dirLight.shadow.camera.left = -200;
          dirLight.shadow.camera.right = 200;
          dirLight.shadow.camera.top = 200;
          dirLight.shadow.camera.bottom = -200;
          dirLight.shadow.mapSize.width = 2048; // Higher resolution for single light
          dirLight.shadow.mapSize.height = 2048;
          scene.add(dirLight);
          dirLights.push(dirLight);
          
          // Increase ambient light for shader material visibility
          const ambientLights = scene.children.filter(child => child.type === 'AmbientLight');
          ambientLights.forEach(light => {
            light.intensity = 0.5; // Increase ambient for better shader visibility
          });
          
          // Configure shadows on text meshes - cast but don't receive to avoid dark artifacts
          floatingText.textMeshes.forEach(mesh => {
            mesh.castShadow = true;
            mesh.receiveShadow = false; // Disable receiving shadows to prevent dark shadow in front
          });
          
          // Animate light with visible movement around the text
          const clock = new THREE.Clock();
          
          function animateLights() {
            const elapsedTime = clock.getElapsedTime();
            
            // Single light orbiting around the text - faster and more visible movement
            const orbitRadius = 300; // Larger orbit radius for more visible movement
            const orbitHeight = 300 + Math.sin(elapsedTime * 0.5) * 80; // More height variation
            const speed = 0.6; // Faster orbit speed (increased from 0.4)
            const angle = elapsedTime * speed;
            
            // Circular orbit around text center
            dirLights[0].position.x = Math.cos(angle) * orbitRadius;
            dirLights[0].position.y = orbitHeight;
            dirLights[0].position.z = -150 + Math.sin(angle) * orbitRadius; // Center around text z position
            
            // Make sure light is looking at the text for better lighting effect
            dirLights[0].target.position.set(0, 0, -150);
            dirLights[0].target.updateMatrixWorld();
            
            // Update shadow camera
            dirLights[0].shadow.camera.updateMatrixWorld();
            
            requestAnimationFrame(animateLights);
          }
          animateLights();
          
          // Log to confirm light is moving (for debugging)
          console.log('Light animation started - light should be moving around text');
          
          // Material presets for shader material
          const presets = {
            chrome: {
              roughness: 0.05,
              anisotropy: 0,
              ior: 2.95,
              clearcoat: 0,
              dispersion: 0,
              metalColor: [0.95, 0.95, 0.98]
            },
            gold: {
              roughness: 0.1,
              anisotropy: 0,
              ior: 0.47,
              clearcoat: 0,
              dispersion: 0,
              metalColor: [1.0, 0.766, 0.336]
            },
            copper: {
              roughness: 0.15,
              anisotropy: 0,
              ior: 0.46,
              clearcoat: 0,
              dispersion: 0,
              metalColor: [0.955, 0.637, 0.538]
            },
            aluminum: {
              roughness: 0.1,
              anisotropy: 0.8,
              ior: 1.39,
              clearcoat: 0,
              dispersion: 0,
              metalColor: [0.913, 0.921, 0.925]
            },
            titanium: {
              roughness: 0.2,
              anisotropy: 0.3,
              ior: 2.16,
              clearcoat: 0.1,
              dispersion: 0.05,
              metalColor: [0.542, 0.497, 0.449]
            },
            pearl: {
              roughness: 0.3,
              anisotropy: 0,
              ior: 1.7,
              clearcoat: 0.8,
              dispersion: 0.15,
              metalColor: [0.95, 0.95, 0.98]
            },
            diamond: {
              roughness: 0.01,
              anisotropy: 0,
              ior: 2.417,
              clearcoat: 1,
              dispersion: 0.3,
              metalColor: [0.98, 0.98, 1.0]
            },
            'car-paint': {
              roughness: 0.2,
              anisotropy: 0,
              ior: 1.5,
              clearcoat: 1,
              dispersion: 0.02,
              metalColor: [0.1, 0.1, 0.5]
            },
            custom: {
              roughness: 0.5,
              anisotropy: 0.5,
              ior: 1.5,
              clearcoat: 0.5,
              dispersion: 0.1,
              metalColor: [0.95, 0.95, 0.98]
            }
          };
          
          // Create shader material uniforms
          const materialUniforms = {
            time: { value: 0 },
            mousePosition: { value: new THREE.Vector2(0.5, 0.5) },
            roughness: { value: 0.05 },
            anisotropy: { value: 0.0 },
            ior: { value: 2.95 },
            clearcoat: { value: 0.0 },
            dispersion: { value: 0.0 },
            metalColor: { value: new THREE.Vector3(0.95, 0.95, 0.98) },
            lightTemperature: { value: new THREE.Vector3(1, 1, 1) }
          };
          
          // Shader material vertex shader
          const vertexShader = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            varying vec3 vWorldPosition;
            varying vec2 vUv;
            varying vec3 vTangent;
            varying vec3 vBitangent;

            void main() {
              vUv = uv;
              vNormal = normalize(normalMatrix * normal);
              vec3 objectTangent = vec3(1.0, 0.0, 0.0);
              vTangent = normalize(normalMatrix * objectTangent);
              vBitangent = cross(vNormal, vTangent);
              vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
              vViewPosition = -mvPosition.xyz;
              vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
              gl_Position = projectionMatrix * mvPosition;
            }
          `;
          
          // Shader material fragment shader
          const fragmentShader = `
            uniform float time;
            uniform vec2 mousePosition;
            uniform float roughness;
            uniform float anisotropy;
            uniform float ior;
            uniform float clearcoat;
            uniform float dispersion;
            uniform vec3 metalColor;
            uniform vec3 lightTemperature;

            varying vec3 vNormal;
            varying vec3 vViewPosition;
            varying vec3 vWorldPosition;
            varying vec2 vUv;
            varying vec3 vTangent;
            varying vec3 vBitangent;

            vec3 fresnelSchlick(float cosTheta, vec3 F0) {
              return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
            }

            float distributionGGX(vec3 N, vec3 H, float roughness) {
              float a = roughness * roughness;
              float a2 = a * a;
              float NdotH = max(dot(N, H), 0.0);
              float NdotH2 = NdotH * NdotH;
              float num = a2;
              float denom = (NdotH2 * (a2 - 1.0) + 1.0);
              denom = 3.14159265359 * denom * denom;
              return num / denom;
            }

            float distributionAnisotropicGGX(vec3 N, vec3 H, vec3 T, vec3 B, float roughness, float anisotropy) {
              float roughnessT = roughness * (1.0 + anisotropy);
              float roughnessB = roughness * (1.0 - anisotropy);
              float dotTH = dot(T, H);
              float dotBH = dot(B, H);
              float dotNH = dot(N, H);
              float a2 = roughnessT * roughnessB;
              float d = dotTH * dotTH / (roughnessT * roughnessT) + 
                       dotBH * dotBH / (roughnessB * roughnessB) + 
                       dotNH * dotNH;
              return 1.0 / (3.14159265359 * roughnessT * roughnessB * d * d);
            }

            float geometrySchlickGGX(float NdotV, float roughness) {
              float r = (roughness + 1.0);
              float k = (r * r) / 8.0;
              float num = NdotV;
              float denom = NdotV * (1.0 - k) + k;
              return num / denom;
            }

            float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
              float NdotV = max(dot(N, V), 0.0);
              float NdotL = max(dot(N, L), 0.0);
              float ggx2 = geometrySchlickGGX(NdotV, roughness);
              float ggx1 = geometrySchlickGGX(NdotL, roughness);
              return ggx1 * ggx2;
            }

            void main() {
              vec3 normal = normalize(vNormal);
              vec3 tangent = normalize(vTangent);
              vec3 bitangent = normalize(vBitangent);
              vec3 viewDir = normalize(vViewPosition);

              // Use the orbiting light position for dynamic lighting
              vec3 lightPos1 = vec3(
                (mousePosition.x - 0.5) * 100.0,
                (mousePosition.y - 0.5) * 100.0,
                5.0
              );
              // Four moving lights orbiting around the equator (horizontal plane)
              float orbitRadius = 80.0;  // Larger radius for more visibility
              float orbitSpeed = 1.0;     // Faster rotation
              float orbitHeight = 0.0;    // Keep at equator (Y = 0)
              
              // Light 2: Rotating around equator, starting at 0 degrees
              vec3 lightPos2 = vec3(
                cos(time * orbitSpeed) * orbitRadius,
                orbitHeight,
                sin(time * orbitSpeed) * orbitRadius
              );
              
              // Light 3: Rotating around equator, 90 degrees offset
              vec3 lightPos3 = vec3(
                cos(time * orbitSpeed + 1.57) * orbitRadius,
                orbitHeight,
                sin(time * orbitSpeed + 1.57) * orbitRadius
              );
              
              // Light 4: Rotating around equator, 180 degrees offset
              vec3 lightPos4 = vec3(
                cos(time * orbitSpeed + 3.14) * orbitRadius,
                orbitHeight,
                sin(time * orbitSpeed + 3.14) * orbitRadius
              );
              
              // Light 5: Rotating around equator, 270 degrees offset
              vec3 lightPos5 = vec3(
                cos(time * orbitSpeed + 4.71) * orbitRadius,
                orbitHeight,
                sin(time * orbitSpeed + 4.71) * orbitRadius
              );

              vec3 color = vec3(0.0);

              vec3 lights[5];
              lights[0] = lightPos1;
              lights[1] = lightPos2;
              lights[2] = lightPos3;
              lights[3] = lightPos4;
              lights[4] = lightPos5;

              vec3 lightColors[5];
              lightColors[0] = lightTemperature;
              lightColors[1] = vec3(0.5, 0.5, 0.7) * lightTemperature;  // Top-left: blue tint
              lightColors[2] = vec3(0.7, 0.5, 0.5) * lightTemperature;  // Top-right: red tint
              lightColors[3] = vec3(0.5, 0.7, 0.5) * lightTemperature;  // Bottom-left: green tint
              lightColors[4] = vec3(0.7, 0.7, 0.5) * lightTemperature;  // Bottom-right: yellow tint

              for(int i = 0; i < 5; i++) {
                vec3 lightDir = normalize(lights[i] - vWorldPosition);
                vec3 halfwayDir = normalize(lightDir + viewDir);

                float n1 = 1.0;
                float n2 = ior;
                float F0_scalar = pow((n1 - n2) / (n1 + n2), 2.0);
                vec3 F0 = mix(vec3(F0_scalar), metalColor, 0.95);

                float D = distributionAnisotropicGGX(normal, halfwayDir, tangent, bitangent, roughness, anisotropy);
                float G = geometrySmith(normal, viewDir, lightDir, roughness);
                vec3 F = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);

                vec3 kS = F;
                vec3 kD = vec3(1.0) - kS;
                kD *= 0.0;

                vec3 numerator = D * G * F;
                float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * max(dot(normal, lightDir), 0.0) + 0.0001;
                vec3 specular = numerator / denominator;

                float NdotL = max(dot(normal, lightDir), 0.0);
                color += (kD * metalColor / 3.14159265359 + specular) * lightColors[i] * NdotL;
              }

              if(clearcoat > 0.0) {
                vec3 clearcoatNormal = normal;
                float clearcoatRoughness = 0.04;

                for(int i = 0; i < 1; i++) {
                  vec3 lightDir = normalize(lights[i] - vWorldPosition);
                  vec3 halfwayDir = normalize(lightDir + viewDir);

                  float D = distributionGGX(clearcoatNormal, halfwayDir, clearcoatRoughness);
                  float G = geometrySmith(clearcoatNormal, viewDir, lightDir, clearcoatRoughness);
                  vec3 F = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), vec3(0.04));

                  vec3 clearcoatSpecular = D * G * F / (4.0 * max(dot(clearcoatNormal, viewDir), 0.0) * max(dot(clearcoatNormal, lightDir), 0.0) + 0.0001);
                  float NdotL = max(dot(clearcoatNormal, lightDir), 0.0);

                  color += clearcoatSpecular * clearcoat * NdotL * lightTemperature;
                }
              }

              float edgeFactor = pow(1.0 - abs(dot(normal, viewDir)), 2.0);
              vec3 dispersionColor = vec3(
                sin(edgeFactor * 3.14159 * 2.0),
                sin(edgeFactor * 3.14159 * 2.0 + 2.094),
                sin(edgeFactor * 3.14159 * 2.0 + 4.189)
              ) * dispersion;

              color += dispersionColor * edgeFactor;
              color += metalColor * 0.03 * lightTemperature;
              color = color / (color + vec3(1.0));
              color = pow(color, vec3(1.0/2.2));

              gl_FragColor = vec4(color, 1.0);
            }
          `;
          
          // Create shader material - exact from 3d-material page
          const customMaterial = new THREE.ShaderMaterial({
            uniforms: materialUniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader
          });
          
          // Apply chrome preset immediately (no controls)
          const chromePreset = presets.chrome;
          materialUniforms.roughness.value = chromePreset.roughness;
          materialUniforms.anisotropy.value = chromePreset.anisotropy;
          materialUniforms.ior.value = chromePreset.ior;
          materialUniforms.clearcoat.value = chromePreset.clearcoat;
          materialUniforms.dispersion.value = chromePreset.dispersion;
          materialUniforms.metalColor.value = new THREE.Vector3(...chromePreset.metalColor);
          
          // Wait a bit to ensure text meshes are created, then replace materials
          setTimeout(() => {
            console.log('Text meshes count:', floatingText.textMeshes.length);
            
            if (floatingText.textMeshes.length === 0) {
              console.error('No text meshes found! Text may not have loaded yet.');
              // Try again after a longer delay
              setTimeout(() => {
                if (floatingText.textMeshes.length > 0) {
                  floatingText.textMeshes.forEach((mesh, i) => {
                    console.log(`Applying shader material to mesh ${i}`);
                    mesh.material = customMaterial;
                    mesh.material.needsUpdate = true;
                  });
                } else {
                  console.error('Text meshes still not found after delay!');
                }
              }, 500);
              return;
            }
            
            // Replace materials on all text meshes with shader material
            floatingText.textMeshes.forEach((mesh, i) => {
              console.log(`Applying shader material to mesh ${i}`);
              mesh.material = customMaterial;
              mesh.material.needsUpdate = true;
            });
          }, 100);
          
          // Mouse interaction for shader - exact from 3d-material page
          const mouse = new THREE.Vector2();
          let isCtrlPressed = false;

          document.addEventListener('keydown', (e) => {
            if (e.key === 'Meta' || e.key === 'Control') isCtrlPressed = true;
          });

          document.addEventListener('keyup', (e) => {
            if (e.key === 'Meta' || e.key === 'Control') isCtrlPressed = false;
          });

          document.addEventListener('mousemove', (event) => {
            mouse.x = event.clientX / window.innerWidth;
            mouse.y = event.clientY / window.innerHeight;
            materialUniforms.mousePosition.value = mouse;
          });
          
          // Disable floating/swaying animations - make text static like 3d-material example
          // Override animate to remove floating but keep everything else
          const originalAnimate = floatingText.animate.bind(floatingText);
          
          floatingText.animate = function() {
            if (this.isDisposed) return;
            this.animationId = requestAnimationFrame(() => this.animate());
            
            const elapsedTime = this.clock.getElapsedTime();
            
            // Mouse-based camera movement (keep this)
            const maxMouseInfluence = 50;
            const mouseScale = 0.5;
            const targetX = Math.max(-maxMouseInfluence, Math.min(maxMouseInfluence, this.mouseX * mouseScale));
            const targetY = Math.max(-maxMouseInfluence, Math.min(maxMouseInfluence, -this.mouseY * mouseScale));
            this.camera.position.x += (targetX - this.camera.position.x) * 0.05;
            this.camera.position.y += (targetY - this.camera.position.y) * 0.05;
            this.camera.lookAt(this.scene.position);
            
            // Animate point light (keep this)
            if (this.pointLight) {
              this.pointLight.position.x = Math.sin(elapsedTime * 0.5) * 80;
              this.pointLight.position.y = Math.cos(elapsedTime * 0.6) * 80;
              this.pointLight.position.z = -150 + Math.sin(elapsedTime * 0.4) * 30;
              this.pointLight.intensity = 1.2 + Math.sin(elapsedTime * 1.5) * 0.5;
            }
            
            // NO SWAYING/FLOATING - keep text meshes in their initial positions
            // Text meshes stay static at their initial positions (no movement, no rotation)
            this.textMeshes.forEach((textMesh, i) => {
              const initialPos = this.textInitialPositions[i];
              if (initialPos) {
                textMesh.position.x = initialPos.x;
                textMesh.position.y = initialPos.y;
                textMesh.position.z = initialPos.z;
                // No rotation animation - keep text static
                textMesh.rotation.x = 0;
                textMesh.rotation.y = 0;
                textMesh.rotation.z = 0;
              }
            });
            
            // Line meshes also stay static (outlines)
            this.textLineMeshes.forEach((lineText, i) => {
              if (this.textInitialPositions[i]) {
                const initialPos = this.textInitialPositions[i];
                lineText.position.x = initialPos.x;
                lineText.position.y = initialPos.y;
                lineText.position.z = initialPos.z;
                lineText.rotation.x = 0;
                lineText.rotation.y = 0;
                lineText.rotation.z = 0;
              }
            });
            
            // Update material time for shader
            if (materialUniforms) {
              materialUniforms.time.value += 0.01;
            }
            
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
          };
          
          // Make sure animation starts
          if (!floatingText.animationId) {
            floatingText.startAnimation();
          }
          
          // Store references for testing
          window.floatingText3D = floatingText;
          window.dirLights = dirLights;
          window.materialUniforms = materialUniforms;
        } catch (error) {
          console.error('Failed to initialize 3D text:', error);
        }
      });
      */
    </script>
</body>
</html>
